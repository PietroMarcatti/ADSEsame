# Define the Edge structure
Edge <- function(to, type, id) {
  list(to = to, type = type, id = id)
}

# Define the Graph structure
Graph <- function(num_nodes) {
  adjacency_list <- vector("list", num_nodes)
  list(
    adjacency_list = adjacency_list,
    addEdge = function(from, to, type, id) {
      adjacency_list[[from + 1]] <- append(adjacency_list[[from + 1]], list(Edge(to, type, id)))
      adjacency_list[[to + 1]] <- append(adjacency_list[[to + 1]], list(Edge(from, type, id)))  # Undirected graph
    },
    getEdges = function(node) {
      return(adjacency_list[[node + 1]])
    }
  )
}

# Define the Path structure
Path <- function(nodes, edges, length, type3_count, type4_count) {
  list(nodes = nodes, edges = edges, length = length, type3_count = type3_count, type4_count = type4_count)
}

# BFS with constraints
findPathsWithConstraints <- function(graph, start_node, max_type3, max_type4) {
  shortest <- vector("list", 196)  # Initialize empty list for storing paths
  shortestDistances <- rep(65534, 196)  # Initialize distances to high value
  queue <- list(Path(c(start_node), integer(0), 0, 0, 0))  # Queue initialized with start node
  
  while (length(queue) > 0) {
    current <- queue[[1]]
    queue <- queue[-1]  # Dequeue
    node <- tail(current$nodes, 1)  # Get the last node in the current path
    
    edge_list <- graph$getEdges(node)  # Get neighbors of the current node
    
    for (edge in edge_list) {
      # Check if the current path is valid
      if (current$length + 1 > shortestDistances[edge$to + 1]) {
        next
      }
      
      # Apply edge type constraints
      new_type3_count <- current$type3_count + (edge$type == 3)
      new_type4_count <- current$type4_count + (edge$type == 4)
      
      if (new_type3_count > max_type3 || new_type4_count > max_type4) {
        next
      }
      
      # Avoid revisiting nodes
      if (edge$to %in% current$nodes) {
        next
      }
      
      # Create a new path
      new_path <- Path(c(current$nodes, edge$to), c(current$edges, edge$id), current$length + 1, new_type3_count, new_type4_count)
      
      if (edge$type == 0) {
        if (new_path$length < shortestDistances[edge$to + 1]) {
          shortestDistances[edge$to + 1] <- new_path$length
          shortest[[edge$to + 1]] <- list(new_path)
        } else if (new_path$length == shortestDistances[edge$to + 1]) {
          shortest[[edge$to + 1]] <- append(shortest[[edge$to + 1]], list(new_path))
        }
      }
      
      # Add the new path to the queue
      queue <- append(queue, list(new_path))
    }
  }
  
  return(shortest)
}

readGraphFromCSV <- function(filename) {
  # Read the CSV file
  data <- read.csv(filename, header = TRUE, stringsAsFactors = FALSE)
  
  # Create a graph with 196 nodes
  graph <- Graph(196)
  
  # Track the maximum node ID
  max_node <- -1
  
  # Process each row of the CSV
  for (i in 1:nrow(data)) {
    row <- data[i, ]
    
    # Skip rows where the first column is greater than 200
    if (row[1] > 200) next
    
    # Extract the values (from, to, type, id)
    from <- as.numeric(row[1])
    to <- as.numeric(row[2])
    type <- as.numeric(row[3])
    id <- as.numeric(row[5])
    
    # Add the edge to the graph
    graph$addEdge(from, to, type, id)
    
    # Update the max node value
    max_node <- max(max_node, from, to)
  }
  
  return(list(graph = graph, max_node = max_node))
}

result <- readGraphFromCSV("datasets/all_edges.csv")
graph <- result$graph
max_node <- result$max_node
# Example usage:
graph <- Graph(10)  # Create a graph with 10 nodes
graph$addEdge(0, 1, 0, 1)
graph$addEdge(1, 2, 3, 2)
graph$addEdge(2, 3, 4, 3)

max_type3 <- 2
max_type4 <- 1

start_node <- 0
paths <- findPathsWithConstraints(graph, start_node, max_type3, max_type4)
print(paths)

